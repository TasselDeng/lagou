### 2021-06-23

##### 1、Dubbo重点掌握什么内容？需要熟悉源码吗？

​		重点掌握： 基于nio的reator模型，自定义的网络协议和TCP的协议解析（粘包等）。先看看mina、netty

用mina实现一个rpc框架



##### 2、区分度不大的数据库表，如何提升查询效率？

数据库中的字段建立索引后，区分度很小，数据总量150w，字段中最大的基数为3w，区分度为2%。建立联合索引后，基数为5.5w，区分度为3.7%。但是整体提升不明显，而且查询到内存中的数据有可能会达到十几万，而且内存中的数据可能会一直被引用不释放，进而引发线上服务OOM，导致服务不可用。



##### 3、支付订单15分钟取消，为什么不用redis的订阅通知实现，是出于什么原因考虑的，SUBSCRIBE __keyevent@0__:expired，redis key过期会发送通知；

​		Redis不是强一致的。故障切换了之后，主从切换有可能会丢数据。 强一致的通知等，一般都是用zk和etcd来做。redis用作存储。职责单一，尽量不要用来做多个事情，有可能你写入存储的请求把订阅的影响了，或者相互影响了。

​		MQ的延时队列，只要不存在消息的阻塞（延迟）和高可靠，是可以的。



##### 4、服务器内存溢出(OOM)和cpu占用过高，有什么区别？分别应该用哪种排查思路解决？

​		1、cpu占用过高，可以说明服务器还没有挂，这时候可以通过top命令，jstack命令来找到对应的cpu耗时严重的线程，进而定位具体的代码逻辑。

​		2、oom的话，说明服务已经挂了，只能通过dump出来的hfds文件来进行具体的分析，来定位到具体类。

linux查看进程OOM killer

```
grep "Out of memory" /var/log/messages
```

java启动命令参数，指定进程挂了，自动把堆信息给打印出来

```
-XX:+HeapDumpOnOutOfMemory
```



##### 5、JVM调优，除了选择适合的垃圾回收器外，还有哪些调优方案？

​		有新生代和老年代的比例调整，比如你要打很多日志，这些日志的生命周期都比较短。那就把新生代放大点，不然太小，就有可能跑到老年代去，触发fullgc了。



##### 6、BIO、NIO 和 AIO 有什么区别？

​		https://blog.csdn.net/dreamer23/article/details/80903978





### 2021-06-21

##### 1、TCP/IP 详解先推荐看哪些？

TCP/IP 物理层，应用层

![image-20210621212126743](%E7%AD%94%E7%96%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.assets/image-20210621212126743.png)



##### 2、NIO中请求注册到多路复用器之后，服务端只有一个线程去操作所有的请求。这样虽然减少了切换线程导致的开销，但是如果是只有一个线程的话，当注册到多路复用器的请求多了以后，会不会产生大量排队，导致性能下降？

​		相对于NIO，有一个BIO。BIO的意识 blocking IO。即每一个网络请求都开一个线程，阻塞的等待客户端请求。这样可以快速响应，但是问题的消耗资源多。NIO的好处当然低资源处理更多的请求。任何技术，大多数解决一个问题的时候，很多的时候会带来其它弊端。NIO的弊端的有可能响应慢。

​		一种解决方案是， 在NIO里，多开几个Selector。一个Selector一个线程。然后将服务端的socket平均的注册到各个Selector里去。

​		AIO是给操作系统注册一个回调函数，这个回调函数是当有网络请求来了之后，进行回调执行的。但是回调也是基于事件的，事件模型就会有延迟问题。但是操作系统的回调要好点



##### 3、redis使用sentinal做高可用的话，能不能做横向扩展。如果需要灵活的扩展性是不是需要用rediscluster？

​		sentinal是做高可用的，做故障切换的。rediscluster是集群。

只要是集群就使用rediscluster，如果只是简单的一主多从的高可用，使用sentinal



##### 4、京东的购物车是如何实现的，数据存在mysql还是redis中？

​		购物车纯缓存，不会用到数据库。

​		raft算法，分布式一致性问题解决。



##### 5、待支付订单，15分钟支付倒计时，到时自动取消是如何实现的？

​		支付倒计时是在创建订单的时候，类似linux里的 crontab一样，创建一个15分钟的定时任务。elastic-job，xxl-jo

### 2021-06-14

##### 1、实时性要求很高的单库单表，数据量很大，怎么拆分？

​		因为实时性要求很高，MySql主从同步赶不上要求。设计成es集群，也会有性能问题。

​		分库不是最佳选择，分库后会有事务问题，查询聚合问题。

​		需要实时性，可以考虑分表，把大表拆成小表，在同一个数据库里可以保证事务。具体操作要根据业务场景，比如有些数据是有状态的，把已完成的数据先移到另一张表去。



##### 2、redis热key如何提前发现？如何解决？（自己实现下？）

​		首先可以根据业务场景提前判断是否可能存在redis热key。

​		具体解决可以改造中间件，每次客户端访问redis时，给前置命令处理器加一个插件，每一次请求都拦截一下，做一个标记，并设置一个阈值，当这个key超过多少次就标记为热key。存入本地缓存中去解决热key问题。如一些本地缓存框架Guava Cache，Caffeine。将热key放到本地缓存中，设置好过期时间和容量大小。利用redis和客户端的长连接通道进行一个消息下发，下次请求时就直接从本地缓存取。

​		为什么本地缓存能够解决热key，因为本地缓存和应用服务器是一起的，有多少台应用服务器，本地缓存就有多少，有一个水平扩展功能。



##### 3、TCP为什么要四次挥手?没有四次挥手连接怎么断开？

​		因为socket是双工的，即客户端可以给服务端发消息。服务端也可以给客户端发消息。所以各有两次挥手，两次挥手分别是发起挥手和确认挥手。因此四次挥手是一个标准流程。

​		除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。

​		服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。



##### 4、使用sharding-jdbc 分库分表



##### 5、接口网络超时怎么办？（其他方案？）

​		读接口超时失败了可以直接重试，没有负面影响。具体超时时间要根据双方业务场景去设置，比如根据近三个月对方接口具体超时次数和时间，做好标记，再设置好对应超时时间。

​		写接口不能直接重试，需要考虑幂等性（对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用）。简单的方式，接口增加一个UUID，代表这次请求的唯一编号。当超时的时候拿这个UUID再去调用提供方接口，提供方可以根据这个UUID从redis或者数据库找这个唯一索引，然后得知是成功还是失败，再做后续操作。

​		

##### 6、TCP建立连接为什么是三次握手？

​		因为要实现全双工。（拜占庭将军问题）



### 2021-06-16

##### 1、数据库的历史业务数据和文件数据一般都是怎么处理的？

​		一般是按数据的时间和状态，进行归档。归档是建立一张和原来一模一样的表，把这些历史数据迁移过去。而不是直接删除，业务数据是资产，一般不会直接进行删除。



##### 2、MySQL死锁问题分析排查

​		可以看MySql数据库引擎的日志，查看这台数据库上最近以及历史上发生的死锁的日志。

```sql
SHOW ENGINE INNODB STATUS
```

![image-20210616214321187](%E7%AD%94%E7%96%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.assets/image-20210616214321187.png)



##### 3、？？？如何做缓存更新？

​		业务代码，手动的写入数据库了，再去把数据更新到缓存里面去。

会出现缓存穿透？？？

开源的binlog工具，canal



##### 4、redis除了要解决性能问题，还要解决什么问题呢？  

​		可以从redis为什么要实现自己的字符串思考。

​		整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？

​		用整数数组和压缩列表，是为了节约内存空间。性能要好，同时占用空间要少。

![image-20210616223146623](%E7%AD%94%E7%96%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.assets/image-20210616223146623.png)

这个128 ，512这些，是redis的配置，表示当数据量小于多少的时候，优先现在这些占用空间小的数据接口，节约空间。当数据多了，查询满了，就会切换到性能更好的数据结构了，只是有点浪费空间。







### 2021-06-07

##### 1、redis 事件分派器和处理器时单线程还是多线程？

​		redis接受命令是多线程。这个接受命令的多线程可以等于和客户端建立的链接。而真正命令执行是单线程，类比java里的 创建一个有界队列，但是最大最小的worker线程就只有一个。所有客户端发送过来的命令，都会放到这个有界队列里，被这一个worker线程串行的执行。所以如果出现一个大key，就会把这个单线程卡住，并且后续所有的请求都会阻塞住，出现雪崩。



##### 2、redis大key怎么解决？场景：比如热门话题评论、大V粉丝列表

​		先查找大key。redis-cli自带的一个命令（不需要连接Redis）。对整个redis进行扫描，寻找较大的key。

```
redis-cli -h 127.0.0.1 -p 6379 --bigkeys
```

​		优化big key的原则就是string减少字符串长度，list、hash、set、zset等减少成员数。

​		现在本地计算最后存储在哪个key中，计算出key的hash值，默认是通过（pin）的hash值，模除100，然后确认存在那个key上面

​		取得时候，同样也需要计算，即：

```
newHashKey = hashKey + (hash(field) % 10000);
hset(newHashKey, field, value);
hget(newHashKey, field);
```



##### 3、内省和反射有什么区别或者有什么关系?

​		内省操作只针对JavaBean，只有符合JavaBean规则的类的成员才可以采用内省API进行操作。而反射则不同，一个类的所有成员都可以进行反射操作。

​		内省和反射的操作也有很大不同，内省是先得到属性描述器PropertyDecriptor后再进行各种操作，反射则是先得到类的字节码Class后再进行各种操作的。

https://www.cnblogs.com/junhuawang/p/7429322.html



##### 4、mysql的查询缓存一般需要开启吗？

​		缓存要开。提升性能除了索引就靠这个了。当再次执行where a=1 and b=1的时候，mysql会复用上的缓存的结果，并在内存里进行b=1过滤。



##### 5、？？？Spring是怎么识别切面点，并且给类生产代理类。同时如何把这个代理类注入到有@Resource和@AutoWired字段的？



##### 6、 ？？？MQ是怎么保证数据不丢失的？



##### 7、？？？kafka的broker和partition的数据结构是什么样的



##### 8、？？？MQ的并行消费和串行消费有什么区别，是如何实现的？



### 2021-06-09

##### 1、秒杀商品业务场景简单，但是这类系统需要保证数据准确性和实时性，业务也就相对复杂，这样的场景该如何设计解决方案？

​		扣减基本的诉求，是不能超卖。不超卖，强一致性的话。用数据库就可以。这种场景可以用在量小的情况下。但是数据量大了会出现死锁。

​		纯使用redis，redis没有事务（ACID），在极端情况下可能会丢数据。在对数据不敏感的场景里，可以使用。

​		可以用redis + 数据库的方案哈，再配合对账。



##### 2、大文件读取

用流式传输，不需要把大文件读到内存中，可以边读大文件边传。伪代码：

```java
byte[] b= file.getInputStream(); socket.getOutputStream().write(b);
```

![image-20210616220311114](%E7%AD%94%E7%96%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.assets/image-20210616220311114.png)



##### 3、？？？redis hash扩容、Java的HashMap和ConcurrentHashMap扩容?

ConcurrentHashMap是渐进式的扩容

redis3.0注释版本源码

https://github.com/huangz1990/redis-3.0-annotated/blob/unstable/src/dict.c

​		Java HashMap 在 new 的时候会初始化，但是不会直接分配长度。会在第一次put的时候初始化，以及达到一定数量的时候调用扩容方法。是一次性扩容，达到条件就会扩容。

​		JDK 1.8 的 HashMap，在链表长度超过8，且数组长度超过64才会将链表转为红黑树。当数组小于64时会先出发扩容。

​		Redis rehash过程，Redis hash 的扩容是渐进式扩容。为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。将rehashindex的值设置为0，表示rehash工作正式开始在rehash期间，每次对字典执行增删改查操作是，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashindex索引上的所有键值对rehash到ht[1]，当rehash工作完成以后，rehashindex的值+1。随着字典操作的不断执行，最终会在某一时间段上ht[0]的所有键值对都会被rehash ht[1]，这时将rehashindex的值设置为-1，表示rehash操作结束。



##### 4、生产MySql怎么升级版本（5.6升级5.7）？

​		MySql5.6升级5.7，会挂一个5.7从库。在用户流量不是很高的时候，将主库设置为readonly，然后看主库的binlog的点位和从库是否一致，如果一致了，将5.7的从库设置为可写，同时进行数据库的ip漂移。
